/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/main.ts
var import_obsidian = __commonJS({
  "src/main.ts"(exports, module) {
    var DEFAULT_SETTINGS = {
      apiKey: "",
      model: "gemini-2.5-flash-lite"
    };
    
    var GeminiPlugin = class extends import_obsidian.Plugin {
      async onload() {
        await this.loadSettings();
        
        // Add settings tab
        this.addSettingTab(new GeminiSettingTab(this.app, this));
        
        // Add command
        this.addCommand({
          id: "send-to-gemini",
          name: "Send text to Gemini",
          editorCallback: (editor, view) => {
            this.sendToGemini(editor);
          }
        });
        
        console.log("Gemini Chat Integration loaded");
      }
      
      onunload() {
        console.log("Gemini Chat Integration unloaded");
      }
      
      async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
      }
      
      async saveSettings() {
        await this.saveData(this.settings);
      }
      
      async sendToGemini(editor) {
        if (!this.settings.apiKey) {
          new import_obsidian.Notice("Please configure your Gemini API key in plugin settings");
          return;
        }
        
        const text = editor.getValue();
        const cursorPosition = editor.getCursor();
        const line = cursorPosition.line;
        const ch = cursorPosition.ch;
        
        // Get all text before cursor as context
        const contextLines = text.split("\n").slice(0, line + 1);
        contextLines[contextLines.length - 1] = contextLines[contextLines.length - 1].substring(0, ch);
        const context = contextLines.join("\n");
        
        // Get all text after cursor as the question
        const questionLines = text.split("\n").slice(line);
        questionLines[0] = questionLines[0].substring(ch);
        const question = questionLines.join("\n").trim();
        
        if (!question) {
          new import_obsidian.Notice("Please type a question after your cursor position");
          return;
        }
        
        try {
          new import_obsidian.Notice("Sending to Gemini...");
          
          // Prepare the prompt with context
          const fullPrompt = context ? `${context}\n\nQuestion: ${question}` : question;
          
          // Generate content using fetch API
          const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.settings.model}:generateContent?key=${this.settings.apiKey}`;
          
          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              contents: [{
                parts: [{
                  text: fullPrompt
                }]
              }]
            })
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`HTTP error! status: ${response.status} - ${errorData.error ? errorData.error.message : "Unknown error"}`);
          }
          
          const data = await response.json();
          
          // Extract response text
          let responseText = "No response received";
          if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
            responseText = data.candidates[0].content.parts[0].text;
          }
          
          // Insert response after the question
          const responseToInsert = `\n\n${responseText}\n\n`;
          editor.setCursor({
            line: line + questionLines.length - 1,
            ch: questionLines[questionLines.length - 1].length
          });
          editor.replaceSelection(responseToInsert);
          
          new import_obsidian.Notice("Response received from Gemini");
        } catch (error) {
          console.error("Error sending to Gemini:", error);
          new import_obsidian.Notice(`Error: ${error.message}`);
        }
      }
    };
    
    var GeminiSettingTab = class extends import_obsidian.PluginSettingTab {
      constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
      }
      
      display() {
        const { containerEl } = this;
        containerEl.empty();
        
        containerEl.createEl("h2", { text: "Gemini Chat Integration Settings" });
        
        new import_obsidian.Setting(containerEl)
          .setName("API Key")
          .setDesc("Your Gemini API key")
          .addText((text) => {
            text.setPlaceholder("Enter your API key")
              .setValue(this.plugin.settings.apiKey)
              .onChange(async (value) => {
                this.plugin.settings.apiKey = value;
                await this.plugin.saveSettings();
              });
          });
        
        new import_obsidian.Setting(containerEl)
          .setName("Model")
          .setDesc("Gemini model to use")
          .addDropdown((dropdown) => {
            dropdown.addOption("gemini-2.5-flash-lite", "Gemini 2.5 Flash Lite")
              .addOption("gemini-pro", "Gemini Pro")
              .setValue(this.plugin.settings.model)
              .onChange(async (value) => {
                this.plugin.settings.model = value;
                await this.plugin.saveSettings();
              });
          });
      }
    };
    
    module.exports = GeminiPlugin;
  }
});

// src/main.ts
var main_exports = {};
__copyProps(main_exports, import_obsidian, true);
module.exports = main_exports;